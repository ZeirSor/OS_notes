# 操作系统王道考研复习——第三章（内存管理/存储器管理）

<!-- TOC -->

- [1. 内存管理概念](#1-内存管理概念)
	- [1.1. 内存管理的基本原理和要求](#11-内存管理的基本原理和要求)
		- [1.1.1. 可执行程序的形成](#111-可执行程序的形成)
		- [1.1.2. 程序的链接](#112-程序的链接)
			- [1.1.2.1. 静态链接](#1121-静态链接)
			- [1.1.2.2. 装入时动态链接](#1122-装入时动态链接)
			- [1.1.2.3. 运行时动态链接](#1123-运行时动态链接)
		- [1.1.3. 程序的装入（装入模块装入内存）](#113-程序的装入装入模块装入内存)
			- [1.1.3.1. 绝对装入（静态装入）](#1131-绝对装入静态装入)
			- [1.1.3.2. 可重定位装入（静态重定位）](#1132-可重定位装入静态重定位)
			- [1.1.3.3. 动态运行时装入（动态重定位）](#1133-动态运行时装入动态重定位)
		- [1.1.4. 内存保护](#114-内存保护)
	- [1.2. 覆盖与交换](#12-覆盖与交换)
		- [1.2.1. 覆盖](#121-覆盖)
		- [1.2.2. 交换](#122-交换)
	- [1.3. 连续分配管理方式](#13-连续分配管理方式)
		- [1.3.1. 内部碎片和外部碎片](#131-内部碎片和外部碎片)
		- [1.3.2. 单一连续分配（无外部碎片，有内部碎片）](#132-单一连续分配无外部碎片有内部碎片)
		- [1.3.3. 固定分区分配（无外部碎片，有内部碎片）](#133-固定分区分配无外部碎片有内部碎片)
		- [1.3.4. 动态分区分配（无内部碎片，有外部碎片）](#134-动态分区分配无内部碎片有外部碎片)
			- [1.3.4.1. 基于顺序搜索的动态分区分配算法（一定要掌握）](#1341-基于顺序搜索的动态分区分配算法一定要掌握)
				- [1.3.4.1.1. ① 首次适应算法（FIrst Fit）](#13411--首次适应算法first-fit)
				- [1.3.4.1.2. ② 最佳适应算法（Best Fit）](#13412--最佳适应算法best-fit)
				- [1.3.4.1.3. ③ 最坏适应算法（Worst Fit）（又称最大适应算法）](#13413--最坏适应算法worst-fit又称最大适应算法)
				- [1.3.4.1.4. ④ 邻近适应算法（Next Fit）（又称循环首次适应算法）](#13414--邻近适应算法next-fit又称循环首次适应算法)
			- [1.3.4.2. 基于索引搜索的动态分区分配算法（这部分作为了解）](#1342-基于索引搜索的动态分区分配算法这部分作为了解)
				- [1.3.4.2.1. ① 快速适应算法（Quick Fit）（又称分类搜索算法）](#13421--快速适应算法quick-fit又称分类搜索算法)
				- [1.3.4.2.2. ② 伙伴系统（Buddy System）](#13422--伙伴系统buddy-system)
				- [1.3.4.2.3. ③ 哈希算法](#13423--哈希算法)
		- [1.3.5. 动态可重定位分区分配](#135-动态可重定位分区分配)
	- [1.4. 非连续分配管理方式（离散分配方式）](#14-非连续分配管理方式离散分配方式)
		- [1.4.1. 基本分页存储管理](#141-基本分页存储管理)
			- [1.4.1.1. 分页存储的几个基本概念](#1411-分页存储的几个基本概念)
			- [1.4.1.2. 地址变换机构](#1412-地址变换机构)
			- [1.4.1.3. 具有快表的地址变换机构（基本地址变换机构的改进版本）](#1413-具有快表的地址变换机构基本地址变换机构的改进版本)
			- [1.4.1.4. 两级页表](#1414-两级页表)
		- [1.4.2. 基本分段存储管理方式](#142-基本分段存储管理方式)
			- [1.4.2.1. 分段](#1421-分段)
			- [1.4.2.2. 段表](#1422-段表)
			- [1.4.2.3. 地址变换](#1423-地址变换)
			- [1.4.2.4. 分段、分页管理的对比](#1424-分段分页管理的对比)
		- [1.4.3. 段页式管理方式](#143-段页式管理方式)
			- [1.4.3.1. 分页、分段管理方式中最大的优缺点：](#1431-分页分段管理方式中最大的优缺点)
			- [1.4.3.2. 先分段再分页](#1432-先分段再分页)
			- [1.4.3.3. 段页式管理的逻辑地址结构](#1433-段页式管理的逻辑地址结构)
			- [1.4.3.4. 地址变换](#1434-地址变换)
	- [1.5. 补充](#15-补充)
- [2. 虚拟内存管理](#2-虚拟内存管理)
	- [2.1. 虚拟内存的基本概念](#21-虚拟内存的基本概念)
		- [2.1.1. 传统存储管理方式的特征和缺点](#211-传统存储管理方式的特征和缺点)
		- [2.1.2. 局部性原理 （在快表那部分已经有简单的介绍）](#212-局部性原理-在快表那部分已经有简单的介绍)
		- [2.1.3. 虚拟内存的定义和特征](#213-虚拟内存的定义和特征)
		- [2.1.4. 虚拟内存技术的实现](#214-虚拟内存技术的实现)
	- [2.2. 请求分页管理方式](#22-请求分页管理方式)
			- [2.2.0.1. 页表机制](#2201-页表机制)
			- [2.2.0.2. 缺页中断机构](#2202-缺页中断机构)
			- [2.2.0.3. 地址变换机构](#2203-地址变换机构)
	- [2.3. 页面置换算法（决定应该换入哪页、换出哪页）](#23-页面置换算法决定应该换入哪页换出哪页)
		- [2.3.1. 最佳置换算法（OPT）](#231-最佳置换算法opt)
		- [2.3.2. 先进先出置换算法（FIFO）](#232-先进先出置换算法fifo)
		- [2.3.3. 最近最久未使用置换算法（LRU）](#233-最近最久未使用置换算法lru)
		- [2.3.4. 时钟置换算法（CLOCK）](#234-时钟置换算法clock)
		- [2.3.5. 改进型的时钟置换算法](#235-改进型的时钟置换算法)
	- [2.4. 页面分配策略](#24-页面分配策略)
		- [2.4.1. 驻留集](#241-驻留集)
		- [2.4.2. 固定分配局部置换](#242-固定分配局部置换)
		- [2.4.3. 可变分配全局置换](#243-可变分配全局置换)
		- [2.4.4. 可变分配局部置换](#244-可变分配局部置换)
		- [2.4.5. 何时调入页面](#245-何时调入页面)
		- [2.4.6. 从何处调入页面](#246-从何处调入页面)
	- [2.5. 抖动](#25-抖动)
	- [2.6. 工作集](#26-工作集)
	- [2.7. 内存映射文件](#27-内存映射文件)
		- [2.7.1. 传统的文件访问方式](#271-传统的文件访问方式)
		- [2.7.2. 内存映射文件的访问方式](#272-内存映射文件的访问方式)
		- [2.7.3. 内存映射文件的优点](#273-内存映射文件的优点)
	- [2.8. 地址翻译](#28-地址翻译)
	- [2.9. 补充](#29-补充)

<!-- /TOC -->

>   存储器管理的主要对象是内存（随机存储器）。对外存的管理与对内存的管理相类似，只是它们的用途不同，外存主要用来存放文件，对于外存的管理放在文件管理一章再介绍。 对于通用计算机而言，存储层次至少应具有三级：最高层为CPU寄存器，中间为主存，最底层是辅存。在较高档的计算机中，还可以根据具体的功能细分为寄存器、高速缓存、主存储器、磁盘缓存、固定磁盘、可移动存储介质等6层。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202254854.png" alt="image-20230720225450745" style="zoom: 33%;" />


 注：


+ ①在计算机系统的存储层次中，寄存器和主存储器又被称为可执行存储器。
+ ②主存储器简称 内存 或 主存。
+ ③寄存器具有与处理机相同的速度，故对寄存器的访问速度最快。
+ ④高速缓存主要用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数，缓和了内存与处理机速度之间的矛盾。当CPU要访问一组特定的信息时，会首先检查它是否在高速缓存中。
+ ⑤磁盘的I/O速度远低于对主存的访问速度，为了缓和两者之间在速度上的不匹配，而设置了磁盘缓存，主要用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数。但磁盘缓存和高速缓存不同，它本身并不是一种实际存在的寄存器，而是利用主存中的部分存储空间暂时存放从磁盘中读出或写入的信息。主存也可以看作是辅存的高速缓存。


关于以上存储层次里的内容就不再一一介绍，这里做个了解即可。 内存管理和进程管理是操作系统的核心内容，需要重点复习。本章围绕分页机制展开：通过分页管理方式在物理内存大小的基础上提高内存的利用率，再进一步引入请求分页管理方式，实现虚拟内存，使内存脱离物理大小的限制，从而提高处理器的利用率。

## 1. 内存管理概念

### 1.1. 内存管理的基本原理和要求

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021916709.png" alt="image-20230602191641641" style="zoom: 80%;" />

内存管理是操作系统设计中最重要和最复杂的内容之一。

-   **操作系统对内存的划分和动态分配就是内存管理。**
-   有效的内存管理在多道程序设计中非常重要，它不仅可以方便用户使用存储器、提高内存利用率，还可以通过虚拟技术从逻辑上扩充存储器。
-   **内存是为了缓和CPU与磁盘之间的速度矛盾。**
-   程序执行前都必须存放在内存中才能被CPU处理。

操作系统在对内存进行管理时，需要负责以下内容：


+ ①操作系统负责内存空间的分配与回收
+ ②操作系统需要提供某种技术从逻辑上对内存空间进行扩充
+ ③操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换
+ ④操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。


#### 1.1.1. 可执行程序的形成


创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：


+ ①编译。由编译程序将用户源代码编译成若干目标模块。（编译就是把高级语言**翻译为机器语言**）
+ ②链接。由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块。
+ ③装入。由装入程序将装入模块装入内存运行。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021834489.png" alt="image-20230602183459433" style="zoom:50%;" />

这里先介绍一下**逻辑地址空间和物理地址空间**

-   编译后，每个目标模块都从0号单元开始编址，这称为该目标模块的**相对地址（或逻辑地址）**。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及内存管理的具体机制。不同进程可以由相同的逻辑地址映射到主存的不同位置。

-   **物理地址**空间是指内存中物理单元的集合，它是地址变换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。


#### 1.1.2. 程序的链接


##### 1.1.2.1. 静态链接

在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021837389.png" alt="image-20230602183737329" style="zoom:50%;" />


##### 1.1.2.2. 装入时动态链接

将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021838090.png" alt="image-20230602183830039" style="zoom:50%;" />


##### 1.1.2.3. 运行时动态链接

对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。

采用这种方式的优点是，**一是便于修改和更新；二是便于实现对目标模块的共享。**

凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅能加快程序的装入过程，而且可**节省大量的内存空间**。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021839018.png" alt="image-20230602183905970" style="zoom:50%;" />


#### 1.1.3. 程序的装入（装入模块装入内存）


##### 1.1.3.1. 绝对装入（静态装入）

在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。绝对装入只适用于单道程序环境。程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021827914.png" alt="image-20230602182754796" style="zoom: 50%;" />


##### 1.1.3.2. 可重定位装入（静态重定位）

在多道程序环境下，多个目标模块的起始地址（简称始址）通常都从0开始，程序中的其他地址都是相对于始址的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入内存的适当位置。装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是**在装入时一次完成的**（逻辑地址变换成物理地址），以后不再改变，所以又称静态重定位。

特点：一个作业装入内存时，必须给它分配要求的全部内存空间，若没有足够的内存，则不能装入该作业。此外，作业一旦进入内存，**整个运行期间就不能在内存中移动，**也不能再申请内存空间。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021920242.png" alt="image-20230602192033173" style="zoom:50%;" />


##### 1.1.3.3. 动态运行时装入（动态重定位）

编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**的支持。允许程序在内存中发生移动。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021921965.png" alt="image-20230602192127894" style="zoom:50%;" />


**小结：**


+ 1）绝对装入（静态装入）是指编程阶段就把物理地址计算好。
+ 2）可重定位装入（静态重定位）是指装入时把逻辑地址转换成物理地址，但装入后不能改变。
+ 3）动态重定位是指执行时再决定装入的地址并装入，装入后有可能会换出，所以同一个模块在内存中的物理地址是可能改变的。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021833058.png" alt="image-20230602183315006" style="zoom:50%;" />

#### 1.1.4. 内存保护


内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护可采用两种方法：


+ 在CPU中设置一对**上、下限寄存器**，存放进程的上、下限地址。进程的指令要访问某个地址时，分别和两个寄存器的值相比，判断有无**越界**。
+ 采用**重定位寄存器**（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行**越界**检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021928075.png" alt="image-20230602192842025" style="zoom:50%;" />

实现内存保护需要重定位寄存器和界地址寄存器。重定位寄存器是用来“加”的，逻辑地址加上重定位寄存器中的值就能得到物理地址；界地址寄存器是用来“比”的，通过比较界地址寄存器中的值与逻辑地址的值来判断是否越界。

### 1.2. 覆盖与交换

覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306021939288.png" alt="image-20230602193918222" style="zoom: 67%;" />

#### 1.2.1. 覆盖


覆盖的基本思想是将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）。不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。

它的特点是，打破了必须将一个进程的全部信息装入主存后才能运行的限制，但要是同时运行程序的代码量大于主存时还是不能运行，此外，内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202255282.png" alt=".*?" style="zoom:67%;" />


 必须由程序员声明覆盖结构，操作系统完成自动覆盖。**缺点：对用户不透明**，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。

#### 1.2.2. 交换


交换（对换）的基本思想是，把处于等待状态（或在CPU调度原则下被剥夺运行权利或是内存空间紧张时）的程序从内存移到辅存，把内存空间腾出来，这一过程称作换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称换入。中级调度采用的就是交换技术，决定将哪个处于挂起状态的进程重新调入内存。

暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）。挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。（这些是第二章的内容，这里做个小复习~） 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202255755.png" alt=".*?" style="zoom:67%;" />

+ 具有对换功能的操作系统中，通常把磁盘空间分为**文件区和对换区**两部分。
    + 文件区主要用于存放文件，主要追求存储空间的利用率，因此对**文件区空间的管理采用离散分配方式**；
    + 对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此**对换区空间的管理主要追求换入换出速度**，因此通常对换区采用**连续分配方式**。总之，**对换区的I/O速度比文件区的更快。**

+ 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。
+ 可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202256104.png" alt=".*?" style="zoom:67%;" />


 注意：**PCB 会常驻内存**，不会被换出外存。因为PCB可以记录着进程被存放在外存的位置等信息。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202256021.png" alt=".*?" style="zoom:67%;" />


 交换技术主要在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。

### 1.3. 连续分配管理方式

连续分配方式是指为一个用户程序分配一个连续的内存空间。

连续分配方式可分为四类：单一连续分配、固定分区分配、动态分区分配以及动态可重定位分区分配算法。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306022009388.png" alt="image-20230602200924314" style="zoom: 80%;" />

#### 1.3.1. 内部碎片和外部碎片

在分配方式之前先介绍一下什么是内部碎片，什么是外部碎片。 

-   **内部碎片**：分配给某进程的内存区域中，有些内存**没有用上**。 
-   **外部碎片**：是指内存中的某些空闲分区由于**太小而难以利用**。【可以通过紧凑（拼凑，Compaction)技术来解决外部碎片。】

#### 1.3.2. 单一连续分配（无外部碎片，有内部碎片）


在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。这种方式不需要进行内存保护，因为内存中永远只有一道程序，因此肯定不会因为访问越界而干扰其他程序。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202256470.png" alt=".*?" style="zoom: 67%;" />


 注意：上面的为低地址，下面的为高地址。

-   优点：实现简单；**无外部碎片**；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。 

-   缺点：只能用于单用户、单任务的操作系统中；**有内部碎片；**存储器利用率极低。

#### 1.3.3. 固定分区分配（无外部碎片，有内部碎片）


固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。 固定分区分配在划分分区时有两种不同的方法：分区大小相等和分区大小不等。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202259721.png" alt="image-20230720225900659" style="zoom:67%;" />

-   **分区大小相等**：缺乏灵活性，但是很**适合用于用一台计算机控制多个相同对象的场合**（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序） 

-   **分区大小不等**：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）
    -   为了便于**内存分配**，操作系统需要建立一个数据结构——**分区说明表**，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。 ![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202259242.png)
    
    -   当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。未找到合适分区时，则拒绝为该用户程序分配内存。
    
    -   优点：实现简单，无外部碎片。 
    
    -   缺点：
        -   ①当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；
        -   ② 主存利用率低，当程序小于固定分区大小时，也占用一个完整的内存分区空间，这样分区内部就会存在空间浪费，从而产生内部碎片。

固定分区分配很少用于现在通用的操作系统中，但在某些<u>用于控制多个相同对象的控制系统</u>中扔发挥着一定的作用。

#### 1.3.4. 动态分区分配（无内部碎片，有外部碎片）

-   **动态分区分配又称为可变分区分配。**这种分配方式**不会预先划分内存分区**，而是在进程装入内存时，**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

-   系统用空闲分区表和空闲分区链这两种常用的数据结构来记录内存的使用情况。 

    -   空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息。 <img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306022000931.png" alt="image-20230602200027889" style="zoom:67%;" />

    -   空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。 <img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306022000035.png" alt="image-20230602200009000" style="zoom: 67%;" />



 在动态分区存储管理方式中，主要的操作是**分配内存**和**回收内存**。 回收内存有三种情况，这三种情况理解起来相对比较简单，这里就不多赘述，具体看图。 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202259350.png)

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202300954.png)

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202300515.png)

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306022004476.png" alt="image-20230602200414399" style="zoom: 80%;" />

 在存储管理中，会产生碎片问题的存储管理方式是动态分区存储管理（指外部碎片）。 分配内存需要用到分区分配算法。

-   **动态分区分配算法**有两种，一种是基于**顺序搜索**的动态分区分配算法，另一种是基于**索引搜索**的动态分区分配算法。

##### 1.3.4.1. 基于顺序搜索的动态分区分配算法（一定要掌握）

为了实现动态分区分配，通常是将系统中的空闲分区链接成一个链。所谓顺序搜索，是指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。基于顺序搜索的动态分区分配算法有如下四种：

###### 1.3.4.1.1. ① 首次适应算法（FIrst Fit）

算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。 

如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202300596.png" alt=".*?" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202300783.png" alt=".*?" style="zoom: 67%;" />

-   优点：优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区。这为以后到达的大作业分配大的内存空间创造了条件。 

-   缺点：低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，称为碎片（又称为“零头”）。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销。

###### 1.3.4.1.2. ② 最佳适应算法（Best Fit）


算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。

如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202302806.png" alt="image-20230720230228760" style="zoom:67%;" />


 缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法**会产生很多的外部碎片**。

###### 1.3.4.1.3. ③ 最坏适应算法（Worst Fit）（又称最大适应算法）


算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306022014292.png" alt="image-20230602201427244" style="zoom: 67%;" />


 缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。

###### 1.3.4.1.4. ④ 邻近适应算法（Next Fit）（又称循环首次适应算法）


算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。

如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202302537.png" alt=".*?" style="zoom:67%;" />


 首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）。邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）。

综合来看，四种算法中，首次适应算法的效果反而更好。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202303684.png" alt="image-20230602201705082" style="zoom: 67%;" />


##### 1.3.4.2. 基于索引搜索的动态分区分配算法（这部分作为了解）

基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，系统中的内存分区可能会很多，相应的空闲分区链就可能很长，这时采用顺序搜索分区方法可能会很慢。为了提高搜索空闲分区的速度，在大、中型系统中往往会采用基于索引搜索的动态分区分配算法。目前常用的有三种：

###### 1.3.4.2.1. ① 快速适应算法（Quick Fit）（又称分类搜索算法）


是按照空闲分区的容量大小进行分类的，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样系统中就会存在多个空闲分区链表。而且还要在内存中设立一张管理索引表，其中的每个索引表项对应一种空闲分区类型。

优点：查找效率高。 缺点：为了有效合并分区，在分区归还主存时的算法复杂，系统开销较大。

###### 1.3.4.2.2. ② 伙伴系统（Buddy System）


该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂（k为整数，1<=k<=m）。通常2m是整个可分配内存的大小（也就是最大分区的大小）。则系统开始运行时，整个内存区是一个大小为2m的空闲分区，在系统运行过程中，由于不断地划分，将会形成若干个不连续的空闲分区，将这些空闲分区按分区的大小进行分类，将大小相同的空闲分区设立在一个空闲分区双向链中。

当分配内存时，会优先从需要分配的内存块链表上查找空闲内存块，当发现对应大小的内存块都已经被使用后，那么会从更大一级的内存块上分配一块内存，并且分成一半给我们使用，剩余的一半释放到对应大小的内存块链表上。反正就是2i要是不够分，就用2i
+1分成两份，一份给我们用，一份放在链表上。回收时则反之。其时间性能比快速适应算法差，但由于它采用了索引搜索算法，比顺序搜索算法好，而其空间性能，由于对空闲分区进行合并，减少了小的空闲分区，提高了空闲分区的可使用率，故优于快速适应算法，比顺序搜索法略差。

###### 1.3.4.2.3. ③ 哈希算法


利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。当进行内存分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。

#### 1.3.5. 动态可重定位分区分配


连续分配方式的一个重要特点是，一个系统或用户程序必须被装入一片连续的内存空间中。当一台计算机运行了一段时间后，它的内存空间将会被分割成许多个小的分区，而缺乏大的空闲空间。即使这些分散的许多小分区的容量总和大于要装入的程序，但由于分区不相邻接，所以没办法将该程序装入内存。这些“碎片”不能满足进程的需求，若想把大作业装入，可采用的一种方法是：将内存中的所有作用进行移动，使它们全都相邻接。这样就可以把原来分散的多个空闲小分区拼接成一个大分区，就可将一个作业装入。这种方式称为”拼接“或”**紧凑**“。 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202305885.png)


 当系统对内存进行”紧凑“操作时，不需要对程序做任何修改，只要用该程序在内存的新起始地址去置换原来的起始地址即可。而该过程中需要用到重定位寄存器，用来存放程序（数据）在内存中的起始地址。地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为动态重定位。 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202307452.png)


 动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅是在这种分配算法中，增加了紧凑的功能。

### 1.4. 非连续分配管理方式（离散分配方式）


支持多道程序的两种连续分配方式：①**固定分区分配**：缺乏灵活性，会产生大量的内部碎片，内存的利用率很低；②**动态分区分配**：会产生很多外部碎片，虽然可以用”紧凑“技术来处理，但是”紧凑“的时间代价很高。考虑到连续分配方式的缺点，所以人们就在想如果可以将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存，而无需再进行”紧凑“操作。基于这一思想，产生了“非连续分配方式”，或者称为“离散分配方式”。

连续分配：为用户进程分配的必须是一个连续的内存空间。 非连续分配：为用户进程分配的可以是一些分散的内存空间。

当然，若采用非连续分配管理方式，需要额外的空间去存储分散区域的索引。然后根据分区的大小是否固定，分为分页存储管理方式和分段存储管理方式。分页存储管理方式又根据运行作业时是否要把作业的所有页面都装入内存才能运行，分为基本分页存储管理方式和请求分页存储管理方式（虚拟内存管理的内容）。

#### 1.4.1. 基本分页存储管理


因希望内存的使用能尽量避免碎片的产生，引入了分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，也以块为单位逐个申请主存中的块空间。

分区和固定分区技术的本质区别就是：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。进程只会在为最后一个不完整的块申请一个内存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片（也称页内碎片）。

##### 1.4.1.1. 分页存储的几个基本概念


+  **什么是分页存储** 
+  将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”（页框=页帧=内存块=物理块=物理页面）。
+  每个页框有一个编号，即“页框号”（页框号=页帧号=内存块号=物理块号=物理页号），页框号从0开始。（前面这些各自对应相同意思的名词都要记住，因为考试的时候每个名词都有可能出现）。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306031722235.png" alt=".*?" style="zoom: 67%;" />

-   将进程的逻辑地址空间也分**为与页框大小相等**的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，页号也是从0开始。 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202307004.png)


 操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，**进程的页面与内存的页框有一一对应的关系。**各个页面不必连续存放，可以放到不相邻的各个页框中。（注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片（页内碎片），因此页框不能太大，否则可能产生过大的内部碎片造成浪费） 
+  **页表** 为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。注：页表通常存在PCB（进程控制块）中。 

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202307856.png)

-   ① 一个进程对应一张页表 

-   ② 进程的每个页面对应一个页表项 

-   ③ 每个页表项由“页号”和“块号”组成 

-   ④ 页表记录进程页面和实际存放的内存块之间的映射关系 

-   ⑤ 每个页表项的长度是相同的 



+  1）在这里我们必须思考，每个页表项占多少个字节呢？ 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202308572.png)

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202309431.png)

 由于页号是隐含的，因此每个页表项占3B，存储整个页表至少需要 3*(n
+1)B。注意：页表记录的只是内存块号，而不是内存块的起始地址，J 号内存块的起始地址 = J * 内存块大小。 

+  2）将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换？ 
    +  特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的。 如果要访问逻辑地址 A，则 
        +  ①确定逻辑地址A 对应的 “页号” P 
        +  ②找到P号页面在内存中的起始地址（需要查页表） 
        +  ③确定逻辑地址A 的 “页内偏移量” 

    +  **W 逻辑地址A 对应的物理地址 = P号页面在内存中的起始地址+页内偏移量W** 

+  而这时又出现了一个新问题：如何确定一个逻辑地址对应的页号、页内偏移量？ 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202310022.png)


 在计算机内部，地址是用二进制表示的，如果页面大小刚好是2 的整数幂，则计算机硬件可以很快速的把逻辑地址拆分成（页号，页内偏移量）。 **页号** = 逻辑地址 / 页面长度 （取除法的整数部分） **页内偏移量** = 逻辑地址 % 页面长度（取除法的余数部分） 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202310157.png)

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202311033.png)


 这部分比较重要，也是计组的内容，这些是关于二进制的除法，想再了解的可以去看看二进制的除法和左移、右移这部分的知识！对于二进制的运算还是必须要能迅速反映比较好！ 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202312979.png" alt="image-20230720231214896" style="zoom: 67%;" />

-   总结：页面大小 刚好是 2 的整数幂有什么好处？ 
    -   ①逻辑地址的拆分更加迅速——如果每个页面大小为 2kB，用二进制数表示逻辑地址，则末尾 K 位，即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为 2 的整数幂，计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度。 
    -   ②物理地址的计算更加迅速——根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。 

+ **逻辑地址结构** 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202312060.png)

 地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。在上图所示的例子中，地址长度为 32 位，其中 0 - 11位 为“页内偏移量”，或称“页内地址”；12 - 31 位为“页号”。 如果有 K 位表示“页内偏移量”，则说明该系统中一个页面的大小是 2K个内存单元（**重要**：页面大小等价于2的页内偏移量位数次幂） 如果有 M 位表示“页号”，则说明在该系统中，一个进程最多允许有 2M 个页面 

提示：有些奇葩题目中页面大小有可能不是2的整数次幂，这种情况还是得用最原始的方法计算： 

-   页号 = 逻辑地址 / 页面长度 （取除法的整数部分） 
-   页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306031739034.png" alt="image-20230603173917955" style="zoom: 80%;" />


##### 1.4.1.2. 地址变换机构

地址变换机构的任务就是通过借助进程的页表将逻辑地址转换成内存中的物理地址。

通常会在系统中设置一个**页表寄存器（PTR）**，存放页表在内存中的**起始地址F 和页表长度M**。

进程未执行时，页表的始址 和 页表长度 放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202313693.png" alt="image-20230720231359642" style="zoom:67%;" />


 地址的变换过程具体如下： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202314997.png" alt=".*?" style="zoom:67%;" />


注意：页面大小是2的整数幂 设页面大小为L，逻辑地址A到物理地址E的变换过程如下：


+ ①计算页号 P 和页内偏移量W（ 如果用十进制数手算，则 P=A/L，W=A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）
+ ②比较页号P 和页表长度（页表项的个数）M，若 P≥M，则产生越界中断，否则继续执行。（注意：页号是从0开始的，而页表长度至少是1，因此 P=M 时也会越界）
+ ③页表中页号P对应的页表项地址 = 页表起始地址F +页号P*页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。**页表长度**指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）
+ ④计算 E = b * L +W，用得到的物理地址E 去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）


这整个过程有两次访问内存：第一次是当页号合法时，要加入内存查页表；第二次是根据物理地址访问物理内存对应的内存单元。 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202314519.png)


 在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的（只要确定了页面大小，然后我们再给出逻辑地址就可以确定页号和页内偏移量）。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。

在实际应用中，通常使一个页框恰好能放入整数个页表项，为了方便查找页表项，页表一般是放在连续的内存块中。具体可以看下图 ：


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202315281.png)

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202315012.png)

 结论：理论上，页表项长度为 3B 即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多的字节，**使得每个页面恰好可以装得下整数个页表项**。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306031808802.png" alt="image-20230603180845720" style="zoom: 67%;" />

##### 1.4.1.3. 具有快表的地址变换机构（基本地址变换机构的改进版本）

**快表，又称联想寄存器（TLB， translation lookaside buffer ）**，是一种访问速度比内存快很多的高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202316491.png" alt="image-20230720231613439" style="zoom:67%;" />


 引入快表后，地址变换过程： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202316110.png" alt=".*?" style="zoom:80%;" />

+ ① CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。
+ ② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
+ ③ 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）

>   例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？ 
>
>   (1+100) * 0.9 +(1+100+100) * 0.1 = 111 us 
>
>   有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是 (1+100) * 0.9 +(100+100) * 0.1 =110.9 us 若未采用快表机制，则访问一个逻辑地址需要 100+100 = 200us 显然，引入快表机制后，访问一个逻辑地址的速度快多了。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202317872.png" alt="image-20230720231717811" style="zoom:67%;" />


 由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到 90% 以上。而什么是局部性原理呢？请看下图： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307210010724.png" alt="image-20230721001001643" style="zoom: 67%;" />


 就我个人理解，快表的局部性原理是由于快表会随着进程的切换而清空然后更新，而进程的代码一般会存放在连续的地方，以及数据也会放在相同的数据段，而快表也会存放着那些被多次访问的页表项，可能会连续多次查到同一个页表项，所以快表具有时间局部性和空间局部性。

基本地址变换和具有快表的地址变换的区别： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202317008.png" alt="image-20230720231748885" style="zoom: 67%;" />


##### 1.4.1.4. 两级页表


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306032013882.png)


 由此看来，单机页表有两个问题，问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。针对这两个问题，产生了两级页表。

两级页表的原理及地址结构： 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202318179.png)


 把原本的20位页号分割成一级页号（页目录号）和二级页号（页表索引）。因此有了页目录表（顶级页表、外层页表）和二级页表。 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202318000.png)

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202319347.png)


能够用较少的内存空间存放页表的唯一方法是，仅把当前需要的一批页表项调入内存，以后再根据需要陆续调入。在采用两级页表结构的情况下，对于正在运行的进程，必须将其页目录表调入内存，而对于页表则只需调入一页或几页。为了表征某页的页表是否已经调入内存，还应再页目录表项中增设一个状态位S，其值若为0，表示该页表分页不在内存中，否则说明其分页已调入内存。


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202320177.png)

 **需要注意的几个细节**： 

①若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说各级页表的大小不能超过一个页面。为了查询方便，顶级页表最多只能有一个页面。

>   例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？ 
>
>   页面大小 = 4KB =2^12^B，按字节编址，因此页内偏移量为12位 页号 = 40 - 12 = 28 位 页面大小 = 2^12^B，页表项大小 = 4B ，则每个页面可存放 2^12^ / 4 = 2^10^个页表项 因此各级页表最多包含 2^10^ 个页表项，需要 10 位二进制位才能映射到 2^10^ 个页表项，因此每一级的页表对应页号应为10位。总共28位的页号至少要分为三级.

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202320395.png)

②两级页表的访存次数分析（假设没有快表机构） 

-   第一次访存：访问内存中的页目录表 
-   第二次访存：访问内存中的二级页表 
-   第三次访存：访问目标内存单元

总结：N级页表访问一个逻辑地址需要**N+1次访存**。多级页表解决了当逻辑地址空间过大时，页表的长度会大大增加的问题。而采用多级页表时，一次访问磁盘需要多次访问内存甚至磁盘，会大大增加一次访存的时间。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306031920846.png" alt="image-20230603192025760" style="zoom: 67%;" />

#### 1.4.2. 基本分段存储管理方式


分页管理方式是从计算机的角度考虑设计的，目的是提高内存的利用率，提升计算机的性能。分页通过硬件机制实现，对用户完全透明。分段管理方式的提出则考虑了用户和程序员，把通常的程序分成若干个段，如主程序段、子程序段A、子程序B……、数据段及栈段等，每个段大多是一个相对独立的逻辑单位，方便于程序员的操作；也满足了方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。

##### 1.4.2.1. 分段

进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻（段内要求连续，段间不要求连续）。由于是按逻辑功能模块划分，用户编程更方便，程序的可读性更高。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202320900.png" alt=".*?" style="zoom:80%;" />


分段系统的逻辑地址构由段号（段名）和段内地址（段内偏移量）所组成。如： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202320818.png" alt=".*?" style="zoom:67%;" />


 段号的位数决定了每个进程最多可以分几个段，段内地址位数决定了每个段的最大长度是多少。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202322223.png" alt="image-20230720232207147" style="zoom: 67%;" />


##### 1.4.2.2. 段表

程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202322009.png)

 ①每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称“基址”）和段的长度。 

②各个段表项的长度是相同的。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位, 段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占 16+32 = 48位，即6B。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表存放的起始地址为 M，则 K号段对应的段表项存放的地址为 M +K*6。

##### 1.4.2.3. 地址变换


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202324616.png)

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202324798.png)


##### 1.4.2.4. 分段、分页管理的对比

-   页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。 
-   段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。

页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。

分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。

分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

**分段比分页更容易实现信息的共享和保护。**

不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的（比如，有一个代码段，只是简单的输出 “Hello World！”）。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）。如按照分段管理方式将进程分段的话，如下图所示： 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202325806.png)


 按照分页管理方式显然是不合理的，具体如下图： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202327336.png" alt="image-20230720232704224" style="zoom:67%;" />

+ 访问一个逻辑地址需要几次访存？ 
    + 分页（单级页表）：
        + 第一次访存——查内存中的页表，
        + 第二次访存——访问目标内存单元。总共两次访存。 

    + 分段：
        + 第一次访存——查内存中的段表，
        + 第二次访存——访问目标内存单元。

+ 总共两次访存。 与分页系统类似，分段系统中也可以引入**快表机构**，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306032113842.png" alt="image-20230603211331754" style="zoom: 67%;" />


#### 1.4.3. 段页式管理方式


页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。将这两种存储管理方法结合起来，便形成了段页式存储管理方式Z。

##### 1.4.3.1. 分页、分段管理方式中最大的优缺点：

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202327002.png" alt=".*?" style="zoom:67%;" />


##### 1.4.3.2. 先分段再分页

将进程按逻辑模块分段，再将各段分页（先分段再分页，如每个页面4KB）。再将内存空间分为大小相同的内存块/页框/页帧/物理块，将各页面分别装入各内存块中。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202328094.png" alt=".*?" style="zoom:67%;" />


##### 1.4.3.3. 段页式管理的逻辑地址结构

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202329562.png" alt=".*?" style="zoom:80%;" />


 段页式系统中的页号和页内偏移量就是把分段系统的逻辑地址的段内地址去进行拆分。段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页，页内偏移量决定了页面大小、内存块大小是多少。

在上图中的例子中，若系统是按字节寻址的，则段号占16位，因此在该系统中，每个进程最多有 216 = 64K 个段,页号占4位，因此每个段最多有 24 = 16页,页内偏移量占12位，因此每个页面/每个内存块大小为 212 = 4096 = 4KB。

**“分段”对用户是可见的**，程序员编程时需要显式地给出段号、段内地址。而将各段**“分页”对用户是不可见**的。系统会根据段内地址自动划分页号和页内偏移量。因此**段页式管理的地址结构是二维的**。


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202329158.png)


 每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，段号是隐含的。

每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。

在一个进程中，段表只有一个，而页表可能有多个。

##### 1.4.3.4. 地址变换


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202331505.png)

 如上图，在段页式系统中，访问一个逻辑地址所需访存次数须三次访问内存，但是可以引入快表机构，以段号和页号为关键字查询快表，即可直接找到最终的目标页面存放地址，引入快表后只需一次访问内存。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306032123508.png" alt="image-20230603212315424" style="zoom:67%;" />

### 1.5. 补充

+  为什么要进行内存管理？ 在单道批处理系统阶段，一个系统在一个时间段内只执行一个程序，内存的分配极其简单，即仅分配给当前运行的进程。引入多道程序的并发执行后，进程之间共享的不仅仅是处理机，还有主存储器。然而，共享主存会形成一些特殊的挑战。若不对内存进行管理，则容易导致内存数据的混乱，以至于限制进程的并发执行。因此。为了更好地支持多道程序并发执行，必须进行内存管理。 
+  在虚拟内存管理中，地址变换机构将逻辑地址变换为物理地址，形成该逻辑地址的阶段是**链接**。（若题目是“完成该变换过程的阶段是”，则是**装载**） 编译后的程序需要经过链接才能装载，而链接后形成的目标程序中的地址也就是逻辑地址。以C语言为例：C程序经过预处理→编译→汇编→链接产生了可执行文件，其中链接的前一步是产生可重定位的二进制目标文件。C语言采用源文件独立编译的方法，如程序main.c，file1.c，file2.c，file1.h，file2.h在链接的前一步生成了main.o，file1.o，file2.o，这些目标模块的逻辑地址都从0开始，但只是相对于该模块的逻辑地址。链接器将这三个文件、libc和其库文件链接成一个可执行文件。链接阶段主要完成重定位，形成整个程序的完整逻辑地址空间。

>   例如，file1.o的逻辑地址为0 ~ 1023，main.o的逻辑地址为0 ~ 1023，假设链接时将file1.o链接在main.o之后，则链接之后file1.o对应的逻辑地址应为1024 ~ 2047，整个过程如下图： 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202331312.png)


+  在使用交换技术时，若一个进程正在I/O操作，则不能交换内存，否则其I/O数据区将被新换入的进程占用，导致错误。不过可以在操作系统中开辟I/O缓冲区，将数据从外设输入或将数据输出到外设的I/O活动在系统缓冲区中进行，这时的系统缓冲区与外设I/O，进程交换都不受限制。 
+  在存储管理中，采用覆盖与交换技术的目的是为了解决主存空间不足的问题，但不是在物理上扩充主存，只是将暂时不用的部分换成内存，以节省空间，从而在逻辑上扩充主存。覆盖技术是早期在单一连续存储管理中使用的扩大存储容量的一种技术，它同样可用于固定分区分配的存储管理。 
+  分区分配内存管理方式的主要保护措施是**界地址保护**。每个进程都拥有自己独立的进程空间，若一个进程在运行时所产生的地址在其地址空间之外，则发生地址越界，因此需要进行界地址保护，即当程序要访问某个内存单元时，由硬件检查是否允许，若允许则执行，否则产生地址越界中断。内存保护需要由操作系统和硬件机构合作完成，以保证进程空间不被非法访问。 
+  固定分区方式中，作业装入后位置不再改变，可以采用静态重定位。 
+  采用分页或分段管理后，提供给用户的物理空间是不能确定的。因为页表和段表都存储在内存中，系统提供给用户的物理地址空间为总空间大小减去页表或段表的长度。由于页表和段表的长度不能确定，所以提供给用户的物理地址空间大小也不能确定。 
+  内存分页管理是在硬件和操作系统层面实现的，对用户、编译系统、连接装配程序等上层是不可见的。所以分页系统中的页面是为操作系统所感知的。 
+  页式存储管理中，页表的始地址存放在**寄存器**中。 
+  对重定位存储管理方式，应在整个系统中设置一个重定位寄存器。 
+  采用段式存储管理时，一个程序如何分段时在**用户编程**时决定的。 
+  可重入程序是通过**减少对换数量**方法来改善系统性能的，可重入程序主要是通过共享来使用同一块存储空间的，或通过动态链接的方式将所需的程序段映射到相关进程中去，其最大的优点是减少了对程序段的调入/调出，因此减少了对换数量。 
+  程序的**动态链接**与程序的逻辑结构有关，分段存储管理将程序按照逻辑段进行划分，因此有利于其动态链接。其他的内存管理方式与程序的逻辑结构无关。 
+  操作系统中实现**分区存储管理**的代价最小，是满足多道程序设计的最简单的存储管理方案，特别适合嵌入式等微型设备。而实现分页、分段和段页式存储管理需要特定的数据结构支持，如页表、段表等，为了提高性能，还需要硬件提供快存和地址加法器等，代价高。 
+  对外存对换区的管理以**提供换入、换出速度**为主要目标。 
+  在页式存储管理中，当页面大时，用于管理页面的页表就少，但是页内碎片会比较大；当页面小时，用于管理页面的页表就大，但是页内碎片小。所以可以通过适当的计算获得较佳的页面大小和较小的系统开销。而当页面大小确定后，所划分的页面大小都必须相等大小。 
+  存储管理的目的有两个：一个是方便用户，二是提高内存利用率。 
+  对主存储器的**访问**，以字节或字为单位。 
+  在分页存储管理中，逻辑地址分配时按页为单位进行分配的，而主存的**分配**即物理地址的分配，是以内存块为单位分配的。（要注意是对主存储器的访问还是分配） 
+  分页存储管理中，作业地址空间是**一维**的，即单一的线性地址空间，程序员只需要一个记忆符来表示地址。在分段存储分配管理中，段之间是独立的，而段长不定长，而页长是固定的，因此作业地址空间是**二维**的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。简言之，确定一个地址需要几个参数，作业地址空间就是几维的。 
+  段页式存储管理汲取了页式管理和段式管理的长处，其实现原理结合了页式和段式管理的基本思想，即用分段方法来分配和管理**用户地址空间**，用分页方法来管理**物理存储空间**。但它的开销要比段式和页式管理的开销大。 
+  一道关于二级页表的题 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202332683.png" alt=".*?" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202332208.png" alt=".*?" style="zoom:50%;" />


 关于多级页表有两个需要注意的点： ①在多级页表的分页存储管理方式中，一个页表最大只能占一个块。 ②有几个二级页表，在一级页表中就有几个页表项。 题解为： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202332305.png" alt=".*?" style="zoom: 67%;" />

注：本节的内容要多做题才能比较好地理解。

## 2. 虚拟内存管理

### 2.1. 虚拟内存的基本概念

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306032130026.png" alt="image-20230603213041944" style="zoom:67%;" />


#### 2.1.1. 传统存储管理方式的特征和缺点

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202334540.png" alt="image-20230720233423472" style="zoom:67%;" />


 传统存储管理方式主要有两个特征：


+ 一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：

    + ①作业很大时，不能全部装入内存，导致大作业无法运行；
    + ②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。

+ 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。 由上述可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业而无法装入运行，显然浪费了宝贵的内存资源。


#### 2.1.2. 局部性原理 （在快表那部分已经有简单的介绍）

+ 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）
+ 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的） 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202334295.png" alt=".*?" style="zoom:80%;" />

而要应对局部性原理可以采用高速缓冲技术的思想：将近期会频繁访问到的数据放到更高速的存储器中，**暂时用不到的数据放在更低速存储器中(外存)**。快表、页高速缓存及虚拟内存技术从广义上讲，都属于高速缓存技术。

#### 2.1.3. 虚拟内存的定义和特征


基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存（换入），然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存（换出）。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。

易混知识点： 虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的 虚拟内存的实际容量 = min（内存和外存容量之和，CPU寻址范围） 


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202334172.png)


 虚拟内存有以下三个主要特征：


+ ①**多次性**：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
+ ②**对换性**：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
+ ③**虚拟性**：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。


#### 2.1.4. 虚拟内存技术的实现


虚拟内存技术允许将一个作业分多次调入内存。采用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202335346.png" alt="image-20230720233543257" style="zoom: 67%;" />


 不管是采用虚拟内存的哪种方式，都需要有一定的硬件支持，一般需要的支持有以下几个方面：


+ 一定容量的内存和外存。
+ 页表机制（或段表机制），作为主要的数据结构。
+ 中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断。
+ 地址变换机构，逻辑地址到物理地址的变换。


### 2.2. 请求分页管理方式


请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。（可以与基本分页存储管理对比学习）。请求分页存储管理方式和基本分页存储管理方式的区别是，前者采用虚拟技术，因此开始运行时，不必将作业一次性全部装入内存，而后者不是。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202336274.png" alt="image-20230720233628154" style="zoom:67%;" />


 在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存中时，再通过调页功能将其调入，同时还可通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。 为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址变换机构。

##### 2.2.0.1. 页表机制


与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存（要注意这里，当页面没有被修改时，就不用重新写回外存了）。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202337162.png" alt="image-20230720233726088" style="zoom: 67%;" />


 相比基本分页管理，请求分页存储管理的页表增加了四个字段。


+ ①状态位（合法位）。用于指示该页是否已调入内存，供程序访问时参考。
+ ②访问字段。用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。
+ ③修改位。标识该页在调入内存后是否被修改过。
+ ④外存地址。用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。


##### 2.2.0.2. 缺页中断机构


在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。

缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断中的”故障“，即可能被系统修复的异常。它同样也要经历保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等几个步骤。但与一般的中断相比，它有以下两个明显的区别：


+ ①在指令执行期间产生和处理中断信号。而不像通常一样，等一条指令执行完再去检查是否有中断请求到达。缺页中断在指令执行期间，若发现所要访问的指令或数据不在内存时，便立即产生和处理缺页中断信号，以便能及时将所缺的页面调入内存。
+ ②一条指令在执行期间，可能产生多次缺页中断。（如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断） 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202338338.png" alt="image-20230720233800267" style="zoom:67%;" />

##### 2.2.0.3. 地址变换机构


请求分页系统中的地址变换机构是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202338745.png" alt=".*?" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306032322085.png" alt="image-20230603232232009" style="zoom:50%;" />


补充细节：（序号和上图的对应）


+ ① 只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。
+ ② 和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。
+ ③ 需要用某种“页面置换算法”来决定一个换出页面。
+ ④ 换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销。
+ ⑤ 页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。 

    + 故在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是： 

        + 查快表(未命中)——
        + 查慢表(发现未调入内存)——
        + 调页(调入的页面对应的表项会直接加入快表)——
        + 查快表(命中)——
        + 访问目标内存单元



**访问内存的有效时间**，有三种情况：


+ 被访问页在内存中，且其对应的页表项在快表中。此时不存在缺页中断情况，内存的有效访问时间（EAT）分为查找快表的时间（λ）和访问实际物理地址所需的时间（t）： EAT=λ+t
+ 被访问页在内存中，且其对应的页表项不在快表中。此时不存在缺页中断情况，但需要两次访问内存，一次读取页表，一次读取数据，另外还需要更新快表。所以，这种情况内存的有效访问时间可分为查找快表的时间、查找页表的时间、修改快表的时间和访问实际物理地址的时间： EAT=λ+t+λ+t
+ 被访问页不在内存中。此时需要进行缺页中断处理，所以这种情况的内存的有效访问时间可分为查找快表的时间、查找页表的时间、处理缺页中断的时间、更新快表的时间和访问实际物理地址的时间：假设缺页中断处理时间为ε，则 EAT=λ+t+ε+λ+t=ε+2(λ+t) 上面的三种情况都没有考虑快表的命中率（α）和缺页率（f）等因素，因此，加入这两个因素后，内存的有效访问时间的计算公式应为 EAT=λ + α x t + (1-α) x [ t + f x (ε + λ + t) + (1 - f) x (λ + t) ]


![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202338096.png)

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306032328041.png" alt="image-20230603232852962" style="zoom: 67%;" />

### 2.3. 页面置换算法（决定应该换入哪页、换出哪页）


请求分页存储管理与基本分页存储管理的主要区别：

在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。此时换出外存并把所要访问的信息调入内存时需要用到的算法称为**页面置换算法**。置换算法的好坏将直接影响到系统的性能。页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率。常见的置换算法有以下四种（**注：在做置换算法的题时记得先把是否缺页的表画出来**）：

#### 2.3.1. 最佳置换算法（OPT）


最佳置换算法（OPT，Optimal）：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202338115.png" alt=".*?" style="zoom:80%;" />


最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。

#### 2.3.2. 先进先出置换算法（FIFO）

先进先出置换算法（FIFO）：每次选择淘汰的页面是最早进入内存的页面。 

实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202341407.png" alt="image-20230720234120339" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202341098.png" alt=".*?" style="zoom:67%;" />


 Belady 异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。 只有 FIFO 算法会产生 Belady 异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差。

#### 2.3.3. 最近最久未使用置换算法（LRU）


最近最久未使用置换算法（LRU，least recently used）：每次淘汰的页面是最近最久未使用的页面，实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202342323.png" alt=".*?" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202342444.png" alt=".*?" style="zoom:80%;" />


 该算法的实现**需要专门的硬件（寄存器和栈）支持**，虽然算法**性能好**，但是实现困难，**开销大**。LRU是堆栈类的算法，理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。

#### 2.3.4. 时钟置换算法（CLOCK）


最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。

时钟置换算法是一种性能和开销较均衡的算法，因为算法要循环扫描缓冲区，像时钟的指针一样在转动，所以又称CLOCK算法，或最近未用算法（NRU，Not Recently Used）。简单的CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面；若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描） 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202343884.png" alt="image-20230720234316745" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202342005.png" alt=".*?" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202342377.png" alt=".*?" style="zoom: 67%;" />


#### 2.3.5. 改进型的时钟置换算法


简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。

**算法规则**：将所有可能被置换的页面排成一个循环队列


+ 第一轮：从当前位置开始扫描到第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位。
+ 第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。本轮将所有扫描过的帧访问位设为0。
+ 第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位。
+ 第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。 由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202343486.png" alt=".*?" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202345533.png" alt=".*?" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202344330.png" alt=".*?" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307202344286.png" alt=".*?" style="zoom:67%;" />


 该算法较简单Clock算法比较，可减少磁盘的I/O操作次数，开销较小，性能也不错。

**小结**： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306032350937.png" alt="image-20230603235039851" style="zoom:67%;" />

### 2.4. 页面分配策略

![image-20230604004906075](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306040049446.png)


#### 2.4.1. 驻留集


驻留集：指请求分页存储管理中给进程分配的物理块的集合。在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；驻留集太大，又会导致多道程序并发度下降，资源利用率降低（CPU或I/O设备等资源有可能出现空闲的情况）。所以应该选择一个合适的驻留集大小。

在请求分页系统中，可采用两种内存分配策略，即固定和可变分配策略。


+ **固定分配**：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。
+ **可变分配**：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。 在进行置换时，也可采用两种策略，即全局置换和局部置换。
+ **局部置换**：发生缺页时只能选进程自己的物理块进行置换。
+ **全局置换**：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307210001251.png" alt=".*?" style="zoom: 80%;" />


 由于固定分配的驻留集大小是不变的，但全局置换时，物理块数量必然会改变，所以不可能是固定分配全局置换。于是，只能组合出以下三种适用的策略：


#### 2.4.2. 固定分配局部置换

系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。

-   这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。
    -   若太少，会频繁出现缺页中断，降低了系统的吞吐量。
    -   若太多，又必然使内存中驻留的进程数目减少，进而可能造成CPU空闲或其他资源空闲的情况，而且在实现进程对换时，会花费更多的时间。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）

#### 2.4.3. 可变分配全局置换


刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个**未锁定**【系统会锁定一些页面，这些页面中的内容不能置换出外存（如：重要的内核数据可以设为“锁定”）】的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。

#### 2.4.4. 可变分配局部置换

刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。



可变分配全局置换和可变分配局部置换的区别： 

-   可变分配**全局**置换：只要缺页就给分配新物理块。 
-   可变分配**局部**置换：要根据发生**缺页的频率**来动态地增加或减少进程的物理块。



为使进程能够正常运行，必须事先将要执行的那部分程序和数据所在的页面调入内存，现在的问题是：

#### 2.4.5. 何时调入页面

+ **预调页策略**：根据局部性原理（主要指空间局部性，即：如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的那些内存单元），一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如 果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要**用于进程的首次调入（运行前调入）**， *由程序员指出*应该先调入哪些部分。
+ **请求调页策略**：进程在运行期间发现缺页时才将所缺页面调入内存**（运行时调入）**。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此**I/O开销较大**。

 一般情况下，两种调页策略会同时使用。


#### 2.4.6. 从何处调入页面

请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。

**对换区**通常采用**连续分配**方式，而**文件区**采用**离散分配**方式，因此对换区的磁盘I/O速度比文件区的更快。


+ **系统拥有足够的对换区空间**：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307210002083.png" alt=".*?" style="zoom:80%;" />

+ **系统缺少足够的对换区空间**：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307210002222.png" alt=".*?" style="zoom:80%;" />

+ **UNIX 方式**：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307210002204.png" alt=".*?" style="zoom:80%;" />

### 2.5. 抖动


刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）。而为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率。所以为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程“工作集”的概念。

### 2.6. 工作集

**驻留集**：指请求分页存储管理中给进程分配的内存块的集合。 

**工作集**：指在某段时间间隔里，进程实际访问页面的集合。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307210003683.png" alt=".*?" style="zoom:80%;" />


 工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。一般来说，**驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。**

拓展：基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。

### 2.7. 内存映射文件

**内存映射文件** —— 操作系统向上层程序员提供的功能（系统调用）

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306040107345.png" alt="image-20230604010705062" style="zoom:50%;" />

#### 2.7.1. 传统的文件访问方式

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306040100744.png" alt="image-20230604010043694" style="zoom:50%;" />

-   open系统调用——打开文件
-   seek系统调用——将读写指针移到某个位置
-   read系统调用——从读写指针所指位置读入若干数据（从磁盘读入内存)
-   wite系统调用——将内存中的指定数据，写回磁盘（根据读写指针确定要写回什么位置)

#### 2.7.2. 内存映射文件的访问方式

-   open系统调用 —— 打开文件
-   mmap系统调用 —— 将文件映射到进、程的虚拟地址空间

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306040103526.png" alt="image-20230604010311477" style="zoom:50%;" />

-   以访问内存的方式访问文件数据
-   文件数据的读入、写出由操作系统自动完成
-   进程关闭文件时，操作系统自动将文件被修改的数据写回磁盘

#### 2.7.3. 内存映射文件的优点

-   方便程序员访问文件数据
-   多个进程可以映射同一个文件，实现**共享**【在物理内存中，一个文件对应同一份数据，当一个进程修改文件数据时，另一个进程可以立马“看到”】

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306040105644.png" alt="image-20230604010528600" style="zoom:50%;" />

### 2.8. 地址翻译


这部分是和计算机组成原理相结合的内容。过后会找个时间完善一下。

### 2.9. 补充

+  虚拟内存（虚存）空间的大小由什么因素决定？ 虚存的容量要满足以下两个条件： ①虚存的实际容量 ≤ 内存容量和外存容量之和，这是硬件的硬性条件规定的，若虚存的实际容量超过了这个容量，则没有相应的空间来供虚存使用。 ②虚存的最大容量 ≤ 计算机的地址位数能容纳的最大容量。假设地址是32位的，按字节编址，一个地址代表1B存储空间，则虚存的最大容量 ≤ 4GB（232B）。这是因为若虚存的最大容量超过4GB，则32位的地址将无法访问全部虚存，也就是说4GB以后的空间被浪费了，相当于没有一样，没有任何意义。 实际虚存的容量是取决条件①和②的交集，即两个条件都要满足，仅满足一个条件是不行的。 
+  虚拟内存是怎么解决问题的？会带来什么问题？ 虚拟内存使用外存上的空间来扩充内存空间，通过一定的换入/换出，使得整个系统在逻辑上能够使用一个远远超出其物理内存大小的内存容量。因为虚拟内存技术调换页面时需要访问外存，会导致平均访存时间增加，若使用了不合适的替换算法，则会大大降低系统性能。 
+  进程在执行中发生了缺页中断，经操作系统处理后，应让其执行被中断的那一条指令。缺页中断调入新页面，肯定要修改页表项和分配页框，同时内存没有页面，需要从外存读入，也会发生磁盘I/O。 
+  虚拟存储技术是补充内存逻辑空间的技术。并未实际扩充内存和外存，而是采用相关技术相对地扩充主存。 虚拟存储器的最大容量是由计算机的地址结构决定的，与主存容量和外存容量没有必然的联系。虽然从实际使用来说，虚拟存储器能使得进程的可用内存扩大道内外存容量之和，但进程内存寻址仍由计算机的地址结构决定，这就决定了虚拟存储器理论上的最大容量。比如，64位系统环境下，虚拟内存技术使得进程可用内存空间达264B，但外存显然是达不到这个大小的。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307210004796.png" alt=".*?" style="zoom: 67%;" />


 虚拟存储技术基于程序的局部性原理。局部性越好，虚拟存储系统越能更好地发挥作用。 虚拟存储扩充内存的基本方法是将一些页或段从内存中调入、调出，而调入、调出的基本手段是覆盖与交换。 
+  请求分页存储管理中，若采用FIFO页面淘汰算法，可能会产生当驻留集增大时，页故障数不减反增的Belady异常。然而，还有另外一种情况。例如，当页面序列为 1，2，3，1，2，3时，页帧数增加，缺页中断会减少。则当可供分配的页帧数增加时，缺页中断的次数可能增加也可能减少。 
+  导致LRU算法实现起来耗费高的原因是需要硬件的特殊支持。LRU算法需要对所有页最近一次被访问的时间进行记录，查找时间最久的进行替换，这涉及到排序，而排序需要硬件的支持。 
+  在虚拟存储器系统的页表项中，决定是否会发生页故障的是合法位（状态位），合法位信息是用来显示本页面是否在内存中的。 
+  在页面置换策略中，所有策略都可能引起抖动。 
+  请求分页存储管理的主要特点是扩充了内存。基于局部性原理，运行一个进程时不需要让整个进程进入内存。 
+  在请求分页存储管理的页表中增加了若干项信息，其中修改位和访问位是供置换算法参考。 
+  产生内存抖动的主要原因是页面置换算法不合理。 
+  在进程运行时，若其工作集页面都在主存储器内（不是虚拟存储器，因为虚拟内存还有硬盘的那部分），则能够使该进程有效地运行，否则会出现频繁的页面调入/调出现象。 
+  覆盖技术与虚拟存储技术有何本质上的不同？交换技术与虚拟存储技术中使用的调入/调出技术有何不同之处？ 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307210007779.png" alt=".*?" style="zoom:67%;" />

 解答： 

-   1）覆盖技术与虚拟存储技术最本质的不同在于，覆盖程序段的最大长度要受内存容量大小的限制，而虚拟存储器中程序的最大长度不受内存容量的限制，只受计算机地址结构的限制。 另外，覆盖技术中覆盖段由程序员设计，且要求覆盖段中的各个覆盖区具有相对独立性，不存在直接联系或相互交叉访问；而虚拟存储技术对用户的程序段没有这种要求。 

    2） 交换技术就是把暂时不用的某个程序及数据从内存移到外存中，以便腾出必要的内存空间，或把指定的程序或数据从外存读到内存中的一种内存扩充技术。 交换技术与虚存中使用的调入/调出技术的主要相同点是，都要在内存与外存之间交换信息。 交换技术与虚存中使用的调入/调出技术的主要区别是：交换技术调入/调出整个过程中，一个进程的大小要受内存容量大小的限制；而虚存中使用的调入/调出技术在内存和外存之间来回传递的是页面或分段，而不受整个进程，从而使得进程的地址映射具有更大的灵活性，且允许进程的大小比可用的内存空间大。 

+  在页式虚存管理系统中，假定驻留集为 m 个页帧（初始所有页帧均为空），在长为 p 的引用串中具有 n 个不同页号（n>m)，对于FIFO、LRU两种页面置换算法，试给出页故障数的上限和下限。 发生页故障的原因是，当前访问的页不在主存，需要将该项调入主存。此时不管主存中是否己满(已满则先调出一页),都要发生一次页故障，即无论怎样安排，n个不同的页号在首次进入主存时必须要发生一次页故障，总共发生n次，这是页故障数的下限。虽然不同的页号数为n小于等于总长度p (访问串可能会有一些页重复出现)，但驻留集m <n,所以可能会有某些页进入主存后又被调出主存，当再次访问时又发生一次页故障的现象， 即有些页可能会出现多次页故障。最差的情况是每访问一个页号时，该页都不在主存中，这样共发生p次故障。 因此，对于FIFO、LRU置换算法，页故障数的上限均为p,下限均为n。 
+  页框号是什么？在置换掉失效页面时页框号会变吗？ 页框号指向的是内存的实际物理地址的页号。在进程启动时，分配了哪些内存块应该是已经确定的（即工作集多大，但也可以是使用全局置换策略变化的）。所以在页面失效时，虚拟页号可能会失效而从快表中删除，但是新的页号替换了那个旧页就继承了它的页框号。 
+  根据数组的随机存取特点，数组在虚拟地址空间中所占的区域必须连续，由于数组不止占用一页，相邻逻辑页在物理上不一定相邻，因此数组在物理地址空间中所占的区域可以不连续。 
+  在请求分页式存储管理中，地址重定位是在指令执行时进行的。 

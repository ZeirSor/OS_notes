# 操作系统考研复习——第五章（设备管理）


<!-- TOC -->

- [1. I/O管理概述](#1-io管理概述)
	- [1.1. I/O设备](#11-io设备)
		- [1.1.1. 什么是I/O设备](#111-什么是io设备)
		- [1.1.2. I/O设备的分类——按使用特性](#112-io设备的分类按使用特性)
		- [1.1.3. I/O设备的分类——按传输速率分类](#113-io设备的分类按传输速率分类)
		- [1.1.4. I/O设备的分类——按信息交换的单位分类](#114-io设备的分类按信息交换的单位分类)
	- [1.2. I/O控制器](#12-io控制器)
		- [1.2.1. I/O设备的机械部件](#121-io设备的机械部件)
		- [1.2.2. I/O设备的电子部件（I/O控制器）](#122-io设备的电子部件io控制器)
		- [1.2.3. I/O控制器的组成](#123-io控制器的组成)
		- [1.2.4. 内存映像I/O v.s. 寄存器独立编址](#124-内存映像io-vs-寄存器独立编址)
	- [1.3. I/O控制方式](#13-io控制方式)
		- [1.3.1. 程序直接控制方式](#131-程序直接控制方式)
		- [1.3.2. 中断驱动方式](#132-中断驱动方式)
		- [1.3.3. DMA方式](#133-dma方式)
		- [1.3.4. 通道控制方式](#134-通道控制方式)
	- [1.4. I/O子系统的层次结构](#14-io子系统的层次结构)
		- [1.4.1. 用户层软件](#141-用户层软件)
		- [1.4.2. 设备独立性软件](#142-设备独立性软件)
		- [1.4.3. 设备驱动程序](#143-设备驱动程序)
		- [1.4.4. 中断处理程序](#144-中断处理程序)
	- [1.5. 补充](#15-补充)
- [2. I/O核心子系统](#2-io核心子系统)
	- [2.1. I/O子系统概述](#21-io子系统概述)
	- [2.2. I/O调度概念](#22-io调度概念)
	- [2.3. 设备保护](#23-设备保护)
	- [2.4. 高速缓存与缓冲区](#24-高速缓存与缓冲区)
		- [2.4.1. 缓冲区的概念和作用](#241-缓冲区的概念和作用)
		- [2.4.2. 单缓冲](#242-单缓冲)
		- [2.4.3. 双缓冲](#243-双缓冲)
		- [2.4.4. 使用单/双缓冲在通信时的区别](#244-使用单双缓冲在通信时的区别)
		- [2.4.5. 循环缓冲区](#245-循环缓冲区)
		- [2.4.6. 缓冲池](#246-缓冲池)
	- [2.5. 设备分配与回收](#25-设备分配与回收)
		- [2.5.1. 设备分配时应考虑的因素](#251-设备分配时应考虑的因素)
			- [2.5.1.1. 设备的固有属性](#2511-设备的固有属性)
			- [2.5.1.2. 设备分配算法](#2512-设备分配算法)
			- [2.5.1.3. 设备分配中的安全性](#2513-设备分配中的安全性)
		- [2.5.2. 静态分配和动态分配](#252-静态分配和动态分配)
		- [2.5.3. 设备分配管理中的数据结构](#253-设备分配管理中的数据结构)
			- [2.5.3.1. 设备控制表（DCT）](#2531-设备控制表dct)
			- [2.5.3.2. 控制器控制表（COCT）](#2532-控制器控制表coct)
			- [2.5.3.3. 通道控制表（CHCT）](#2533-通道控制表chct)
			- [2.5.3.4. 系统设备表（SDT）](#2534-系统设备表sdt)
		- [2.5.4. 设备分配的步骤](#254-设备分配的步骤)
		- [2.5.5. 设备分配步骤的改进](#255-设备分配步骤的改进)
	- [2.6. SPOOLing技术（假脱机技术）](#26-spooling技术假脱机技术)
		- [2.6.1. 脱机技术的概念](#261-脱机技术的概念)
		- [2.6.2. 假脱机技术——输入井和输出井](#262-假脱机技术输入井和输出井)
		- [2.6.3. 假脱机技术——输入进程和输出进程](#263-假脱机技术输入进程和输出进程)
		- [2.6.4. 假脱机技术——输入/输出缓冲区](#264-假脱机技术输入输出缓冲区)
		- [2.6.5. 共享打印机原理分析](#265-共享打印机原理分析)
	- [2.7. 补充](#27-补充)

<!-- /TOC -->


I/O系统管理的主要对象是I/O设备和相应的设备控制器。其主要的任务是，完成用户提出的I/O请求，提高I/O速率，以及提高设备的利用率，并能为更高层的进程方便地使用这些设备提高手段。

## 1. I/O管理概述

### 1.1. I/O设备

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306042244712.png" alt="image-20230604224449602" style="zoom: 40%;" />


#### 1.1.1. 什么是I/O设备


“I/O” 就是 “输入/输出”（Input/Output）。 I/O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212048332.png" alt=".*?" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212048283.png" alt=".*?" style="zoom:50%;" />


#### 1.1.2. I/O设备的分类——按使用特性

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212050058.png" alt="image-20230721205037984" style="zoom:50%;" />


#### 1.1.3. I/O设备的分类——按传输速率分类

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212049659.png" alt="image-20230721204945593" style="zoom:50%;" />


 字节多路通道用做连接低速或中速的I/O设备。

#### 1.1.4. I/O设备的分类——按信息交换的单位分类

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212051594.png" alt=".*?" style="zoom:40%;" />


### 1.2. I/O控制器

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212051579.png" alt=".*?" style="zoom:40%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306042252244.png" alt="image-20230604225210084" style="zoom:43%;" />

#### 1.2.1. I/O设备的机械部件


I/O设备的**机械部件**主要用来执行具体I/O操作。 如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。

#### 1.2.2. I/O设备的电子部件（I/O控制器）


I/O设备的**电子部件**通常是一块插入主板扩充槽的印刷电路板。

CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的“中介”，用于实现CPU对设备的控制。这个电子部件就是I/O控制器，又称设备控制器。CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。

<img src="./figures\00b94efaefb04b5bad59cdd1a5d174af.png" alt=".*?" style="zoom:50%;" />


#### 1.2.3. I/O控制器的组成


由于I/O控制器位于CPU和设备之间，它既要与CPU通信，又要与设备通信，还应具有按照CPU所发来的命令去控制设备工作的功能，因此，现有的大多数控制器都是由**设备控制器与处理机的接口**、**设备控制器与设备的接口**和**I/O逻辑**三部分组成。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212053359.png" alt=".*?" style="zoom:50%;" />


 由于I/O设备的速率较低，而CPU和内存的速率却很高，故在控制器中必须设置一个数据缓冲区。在输出时，用此缓冲区暂存在主机高速传来的数据，然后才以与I/O设备所匹配的速率将缓冲器中的数据传送给I/O设备。在输入时，缓冲区则用于暂存从I/O设备送来的数据，待接收到一批数据后，再将缓冲区中的数据高速地传送给主机。

**值得注意的小细节**：


+ 一个I/O控制器可能会对应多个设备；
+ 数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O；另一些计算机则采用I/O专用地址，即寄存器独立编址。


#### 1.2.4. 内存映像I/O v.s. 寄存器独立编址

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212053950.png)


### 1.3. I/O控制方式


在I/O控制方式的整个发展过程中，始终贯穿着这样一条宗旨，即尽量减少主机对I/O控制的干预，把主机从繁杂的I/O控制事务中解脱出来，以便更多地去完成数据处理任务。

设备管理的主要任务之一是控制设备和内存或处理机之间的数据传送。外围设备和内存之间的输入/输出控制方式有4中。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212053704.png" alt=".*?" style="zoom:50%;" />


#### 1.3.1. 程序直接控制方式

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212054699.png" alt=".*?" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212054177.png" alt=".*?" style="zoom:50%;" />

+ CPU干预的频率 很频繁，I/O操作开始之前、完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断地轮询检查。
+ 数据传送的单位 每次读/写一个字。
+ 数据的流向 读操作（数据输入）：I/O设备→CPU（指的是CPU的寄存器）→内存 写操作（数据输出）：内存→CPU→I/O设备 每个字的读/写都需要CPU的帮助
+ 主要缺点和主要优点 优点：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”） 缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态 ，CPU利用率低。


#### 1.3.2. 中断驱动方式


引入中断机制。由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。当I/O完成后，控制器会向CPU发出一个中断信号，CPU 检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行。

注意： 

①CPU会在每个指令周期的末尾检查中断； 

②中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212055618.png" alt=".*?" style="zoom: 67%;" />

+ CPU干预的频率 每次I/O操作开始之前、完成之后需要CPU介入。 等待I/O完成的过程中CPU可以切换到别的进程执行。
+ 数据传送的单位 每次读/写一个字
+ 数据的流向 读操作（数据输入）：I/O设备→CPU→内存 写操作（数据输出）：内存→CPU→I/O设备
+ 主要缺点和主要优点 
    + 优点：
        + 与“程序直接控制方式”相比，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询。
        + CPU和I/O设备可并行工作，CPU利用率得到明显提升。 

    + 缺点：
        + 每个字在I/O设备与内存之间的传输，都需要经过CPU。
        + 而频繁的中断处理会消耗较多的CPU时间。



#### 1.3.3. DMA方式

与“中断驱动方式”相比，**DMA方式（ Direct Memory Access，直接存储器存取**。主要用于块设备的I/O控制）有这样几个改进： 

-   ①数据的**传送单位是“块”**。不再是一个字、一个字的传送； 
-   ②数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”。 
-   ③仅在传送一个或多个数据块的**开始和结束**时，才需要CPU干预。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212055616.png" alt=".*?" style="zoom: 50%;" />


 **DMA控制器的组成：** 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212056785.png" alt="image-20230721205656729" style="zoom:67%;" />


 命令/状态寄存器控制DMA的工作模式并给CPU反映它当前的状态，地址寄存器存放DMA作业时的源地址和目标地址，数据寄存器存放要DMA转移的数据。

DMA方式是在I/O设备与主存之间建立一条直接数据通路。是一种不经过CPU而直接从主存存取数据的数据交换模式，不过这条数据通路只是逻辑上的，实际并未直接建立一条物理线路，而通常是通过总线进行的。


+ CPU干预的频率 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。
+ 数据传送的单位 每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）。
+ 数据的流向（不再需要经过CPU） 读操作（数据输入）：I/O设备→内存 写操作（数据输出）：内存→I/O设备
+ 主要缺点和主要优点 

    + 优点：

        + 数据传输以“块”为单位，CPU介入频率进一步降低。
        + 数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。
        + **CPU和I/O设备的并行性得到提升**。 

    + 缺点：

        + CPU每发出一条I/O指令，只能读/写**一个或多个连续**的数据块。 
        + 如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。



#### 1.3.4. 通道控制方式


**通道**：一种硬件，可以理解为是 “弱鸡版的CPU”（与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存。）通道可以识别并执行一系列通道指令。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212057430.png" alt="image-20230721205736369" style="zoom:67%;" />


 编制好的通道程序是存放在主存中的。 来自通道的I/O中断事件由设备管理负责处理。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212057682.png" alt=".*?" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212058510.png" alt=".*?" style="zoom:67%;" />


 CPU启动通道时不管成功与否，通道都要回到CPU，通道在执行通道程序的过程中，CPU与通道并行，通道完成同道程序的执行后，便发I/O中断向CPU报告。

设置通道后，CPU只需向通道发送一条I/O指令。通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道完成规定的I/O任务后，才向CPU发出中断信号。因此通道用于完成内存与外设的信息交换。


+ CPU干预的频率 极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。
+ 数据传送的单位 每次读/写一组数据块。
+ 数据的流向（在通道的控制下进行） 

    + 读操作（数据输入）：I/O设备→内存 
    + 写操作（数据输出）：内存→I/O设备

+ 主要缺点和主要优点 

    + 缺点：实现复杂，需要专门的通道硬件支持。 
    + 优点：CPU、通道、I/O设备可并行工作，资源利用率很高。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212058032.png" alt=".*?" style="zoom: 50%;" />


### 1.4. I/O子系统的层次结构


为了使复杂的I/O软件具有清晰的结构、良好的可移植性和适应性，在I/O软件中普遍采用了层次式结构，将系统输入/输出功能组织成一系列的层次，每层都利用其下层提供的服务，完成输入/输出功能中的某些子功能，并屏蔽执行功能实现的细节，向高层提供服务。在层次式结构的I/O软件中，只要层次间的接口不变，对某一层次中的软件的修改都不会引起其下层或高层代码的变更，仅最底层才涉及硬件的具体特性。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212058750.png" alt=".*?" style="zoom: 50%;" />


#### 1.4.1. 用户层软件

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212100593.png" alt="image-20230721210014530" style="zoom: 67%;" />


 一般而言，大部分的I/O软件都在操作系统的内部，但仍有一小部分在用户层，包括与用户程序链接在一起的库函数，以及完全运行于内核之外的一些程序。用户层软件必须通过一组系统调用来获取操作系统服务。

#### 1.4.2. 设备独立性软件


设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。

这一层**主要实现的功能**：


+  向上层提供统一的调用接口（如 read/write 系统调用）。 
+  设备的保护。（原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样）。 
+  差错处理。（设备独立性软件需要对一些设备的错误进行处理）。 
+  设备的分配与回收。 
+  数据缓冲区管理。（可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异） 
+  建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序。（用户或用户层软件发出I/O操作相关系统调用的系统调用时，需要指明此次要操作的I/O设备的逻辑设备名（eg：去学校打印店打印时，需要选择 打印机1/打印机2/打印机3 ，其实这些都是逻辑设备名）；设备独立性软件需要通过“逻辑设备表（LUT，Logical UnitTable）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序）。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212101537.png" alt="image-20230721210126493" style="zoom: 67%;" />


 操作系统系统可以采用两种方式管理逻辑设备表（LUT）： 第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。 第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。


思考：为什么不同类型的I/O设备需要有不同的驱动程序处理？ 各式各样的设备，外形不同，其内部的电子部件（I/O控制器）也有可能不同 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212101948.png" alt=".*?" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212102338.png" alt=".*?" style="zoom:50%;" />


不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设 备寄存器，检查设备状态等工作。 系统只要按设备类型配置设备驱动程序即可，即每类设备只需一个设备驱动程序。

#### 1.4.3. 设备驱动程序

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212102976.png" alt=".*?" style="zoom:50%;" />


与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。

#### 1.4.4. 中断处理程序


当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212103177.png" alt="image-20230721210343114" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212104259.png" alt="image-20230721210435167" style="zoom:65%;" />


### 1.5. 补充

+ 可寻址是块设备的基本特征。共享设备必须是可寻址的和可随机访问的设备。分配共享设备是不会引起进程死锁的。
+ 虚拟设备是指把一个物理设备变换成多个对应的逻辑设备。不允许用户使用比系统中具有的物理设备更多的设备。
+ 磁盘设备的I/O控制主要采用DMA方式。因为磁盘是典型的块设备，而DMA方式主要用户块设备。
+ 为了便于上层软件的编制，设备控制器通常需要提供控制寄存器、状态寄存器和控制命令。控制寄存器和状态寄存器分别用于接收上层发来的命令并存放设备状态信号，是设备控制器与上层的接口；至于控制命令，每种设备对应的设备控制器都对应一组相应的控制命令，CPU通过控制命令控制设备控制器。而中断寄存器是位于计算机主机，不存在I/O地址寄存器。
+ 在设备控制器中用于实现设备控制功能的是I/O逻辑。而接口是用来传输信号的。
+ 在设备管理中，设备映射表（DMT）的作用是建立逻辑设备与物理设备的对应关系。
+ 通道是一种特殊的处理器，所以属于硬件技术。SPOOLing、缓冲池、内存覆盖都是在内存的基础上通过软件实现的。
+ 设备分配时应考虑设备的固有属性、设备独立性和设备安全性，一般不需要考虑及时性。设备的固有属性决定了设备的使用方式，设备独立性可以提高设备分配的灵活性和设备的利用率，设备安全性可以保证分配设备时不会导致永久阻塞。
+ 计算机系统为每台设备确定一个编号以便区分和识别设备，这个确定的编号称为设备的绝对号。
+ 关于通道、设备控制器和设备之间的关系是，通道控制设备控制器，设备控制器控制设备。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212106831.png" alt=".*?" style="zoom: 80%;" />

+ 所有设备的启动工作都由系统统一来做。
+ 本地用户通过键盘登录系统时，首先获得键盘输入信息的程序是中断处理程序。键盘是典型的通过中断I/O方式工作的外设，当用户输入信息时，计算机响应中断并通过中断处理程序获得输入信息。
+ 将系统调用参数翻译成设备操作命令的工作由设备无关的操作系统软件完成。系统调用命令是操作系统提供给用户程序的通用接口，不会因为具体设备的不同而改变。而设备驱动程序负责执行操作系统发出的I/O命令，它因设备不同而不同。
+ 计算磁盘号、磁头号和扇区号的工作是由设备驱动程序完成的。
+ DMA控制方式与中断控制方式的主要区别如下： 
	+ 1）中断控制方法在每个数据传送完成后中断CPU，而DMA控制方式则在所要求传送的一批数据全部传送结束时中断CPU。 
	+ 2）中断控制方式的数据传送在中断处理时由CPU控制完成，而DMA控制方式则在DMA控制器的控制下完成。不过，在DMA控制方式中，数据传送的方向、存放数据的内存始址及传送数据的长度等仍然由CPU控制。 
	+ 3）DMA方式以存储器为核心，中断控制方式以CPU为核心。因此DMA方式能与CPU并行工作。 
	+ 4）DMA方式传输批量的数据，中断控制方式的传输则以字节为单位。
+ DMA方式与通道方式的主要区别是什么？ 在DMA控制方式中，在DMA控制器控制下设备和主存之间可以成批地进行数据交换而不用CPU干预，这样既减轻了CPU的负担，又大大提高了I/O数据传送的速度。通道控制方式与DMA控制方式类似，也是一种以内存为中心实现设备与内存直接交换数据的控制方式。不过在通道控制方式中，CPU只需发出启动指令，指出通道相应的操作和I/O设备，该指令就可以启动通道并使通道从内存中调出相应的通道程序执行。与DMA控制方式相比，通道控制方式所需的CPU干预更少，并且一个通道可以控制多台设备，进一步减轻了CPU的负担。另外，对通道来说，可以使用一些指令灵活改变通道程序，这一点DMA控制方式无法做到。

## 2. I/O核心子系统

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306051640235.png" alt="image-20230605164034089" style="zoom:43%;" />

### 2.1. I/O子系统概述


由于I/O设备种类繁多，功能和传输速率差异巨大，因此需要多种方法来进行设备控制。这些方法共同组成了操作系统内核的I/O子系统，它将内核的其他方面从繁重的I/O设备管理中解放出来。I/O核心子系统提供的服务主要有I/O调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212107778.png" alt="image-20230721210752716" style="zoom: 67%;" />

**这些功能在哪一层实现？** 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212108207.png" alt=".*?" style="zoom: 50%;" />


 **设备保护：** 操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如：只读、读和写等）。 在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。（参考“文件保护”小节）

### 2.2. I/O调度概念


I/O调度：用某种算法确定一个好的顺序来处理各个I/O请求。

如：磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。当多个磁盘I/O请求到来时，用某种调度算法确定满足I/O请求的顺序。 同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定I/O调度顺序。

### 2.3. 设备保护

操作系统需要实现**文件保护功能**，不同的用户对各个文件有不同的访问权限（如：只读、读和写等)。
在UNIX系统中，**设备被看做是一种特殊的文件**，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据CB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。（参考“文件保护”小节）

### 2.4. 高速缓存与缓冲区


#### 2.4.1. 缓冲区的概念和作用


缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。 使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本） 一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212109419.png" alt="image-20230721210925358" style="zoom:50%;" />


#### 2.4.2. 单缓冲


假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。

**注意**：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212111928.png" alt="image-20230721211110877" style="zoom:50%;" />

+   1）假设T>C

<img src="./figures\d9fec362bfa4491fb43d6d54adef05f5.png" alt=".*?" style="zoom:50%;" />

-   2）假设T<C

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212111753.png" alt="image-20230721211154706" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212112496.png" alt="image-20230721211229449" style="zoom: 50%;" />


#### 2.4.3. 双缓冲


假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）

双缓冲题目中，假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空。

-   1）假设T>C+M

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212112497.png" alt="image-20230721211250449" style="zoom:50%;" />

-   2）假设T<C+M 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212114143.png" alt="image-20230721211457078" style="zoom:60%;" />


 结论：采用双缓冲策略，处理一个数据块的平均耗时为 Max (T, C+M)。

#### 2.4.4. 使用单/双缓冲在通信时的区别


两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212115686.png" alt=".*?" style="zoom: 67%;" />

 显然，若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212116503.png" alt="image-20230721211657456" style="zoom:80%;" />


 若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。 注：管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道=。

#### 2.4.5. 循环缓冲区

将多个大小相等的缓冲区链接成一个循环队列。 

注：以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212116786.png" alt=".*?" style="zoom:80%;" />


#### 2.4.6. 缓冲池


缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。 另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212118614.png" alt=".*?" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212117816.png" alt=".*?" style="zoom:60%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212117378.png" alt=".*?" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212119336.png" alt=".*?" style="zoom: 67%;" />

### 2.5. 设备分配与回收

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306051656008.png" alt="image-20230605165647809" style="zoom:43%;" />


设备分配是根据用户的I/O请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方式造成进程死锁。

#### 2.5.1. 设备分配时应考虑的因素

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212119247.png" alt="image-20230721211949210" style="zoom:67%;" />


##### 2.5.1.1. 设备的固有属性

设备的固有属性可分为三种：独占设备、共享设备、虚拟设备。

-   **独占设备**——一个时段只能分配给一个进程（如打印机） 
-   **共享设备**——可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。 
-   **虚拟设备**——采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）

##### 2.5.1.2. 设备分配算法

设备的分配算法： 先来先服务、优先级高者优先、短任务优先 ……

##### 2.5.1.3. 设备分配中的安全性

从进程运行的安全性上考虑，设备分配有两种方式：

-   **安全分配方式**：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。（eg：考虑进程请求打印机打印输出的例子） 一个时段内每个进程只能使用一个设备。 
    -   **优点**：破坏了“请求和保持”条件，不会死锁。 
    -   **缺点**：对于一个进程来说，CPU和I/O设备只能串行工作。

-   **不安全分配方式**：进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。 一个进程可以同时使用多个设备。 
    -   **优点**：进程的计算任务和I/O任务可以并行处理，使进程迅速推进。 
    -   **缺点**：有可能发生死锁（死锁避免、死锁的检测和解除）。

#### 2.5.2. 静态分配和动态分配

**静态分配**：进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了“请求和保持”条件，不会发生死锁。 

**动态分配**：进程运行过程中动态申请设备资源。

#### 2.5.3. 设备分配管理中的数据结构


“设备、控制器、通道”之间的关系： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212120560.png" alt=".*?" style="zoom:50%;" />


 一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。

##### 2.5.3.1. 设备控制表（DCT）

设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212120145.png" alt="image-20230721212050074" style="zoom: 67%;" />


##### 2.5.3.2. 控制器控制表（COCT）

控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212121357.png" alt="image-20230721212144299" style="zoom:67%;" />


##### 2.5.3.3. 通道控制表（CHCT）

通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212122258.png" alt="image-20230721212213201" style="zoom: 67%;" />


##### 2.5.3.4. 系统设备表（SDT）

系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212122166.png" alt=".*?" style="zoom: 67%;" />


#### 2.5.4. 设备分配的步骤

+ 根据进程请求的物理设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数） 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212122924.png" alt=".*?" style="zoom: 67%;" />

+ 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212123432.png" alt="image-20230721212329378" style="zoom:67%;" />

+ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212123272.png" alt="image-20230721212356221" style="zoom: 67%;" />

+ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212124802.png" alt="image-20230721212407758" style="zoom:67%;" />

注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送。

**缺点**： 

①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程。 

②若换了一个物理设备，则程序无法运行。 

③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待。

**改进方法**：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名。

#### 2.5.5. 设备分配步骤的改进

+ 根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）
+ 查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。
+ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
+ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212124315.png" alt="image-20230721212435260" style="zoom:67%;" />


 逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系。 某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。 如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。

逻辑设备表的设置问题： **整个系统只有一张LUT**：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统。 **每个用户一张LUT**：不同用户的逻辑设备名可重复，适用于多用户操作系统

### 2.6. SPOOLing技术（假脱机技术）

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202306051647482.png" alt="image-20230605164718371" style="zoom:43%;" />


#### 2.6.1. 脱机技术的概念

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212125606.png" alt=".*?" style="zoom: 50%;" />


 **手工操作阶段**：主机直接从 I/O设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212125343.png" alt=".*?" style="zoom:50%;" />


 **批处理阶段**引入了脱机输入/输出技术（用磁带完成）。

#### 2.6.2. 假脱机技术——输入井和输出井


“**假脱机技术**”，又称“**SPOOLing 技术**”是用软件的方式模拟脱机技术。SPOOLing 系统的组成如下： 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212125345.png" alt=".*?" style="zoom:50%;" />


 用户的打印结果首先是送到位于磁盘固定区域的输出井。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212126404.png" alt="image-20230721212636329" style="zoom:67%;" />


#### 2.6.3. 假脱机技术——输入进程和输出进程

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212127935.png" alt="image-20230721212715891" style="zoom:67%;" />


 要实现SPOOLing 技术，必须要有多道程序技术的支持。系统会建立 “输入进程”和 “输出进程”。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212127256.png" alt=".*?" style="zoom:50%;" />


 输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井。当 CPU 需要输入数据时，直接将数据从输入井读入内存。输出进程模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备。

#### 2.6.4. 假脱机技术——输入/输出缓冲区

![.*?](https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212128233.png)


#### 2.6.5. 共享打印机原理分析

**独占式设备**——只允许各个进程串行使用的设备。一段时间内只能满足一个进程的请求。 **共享设备**——允许多个进程“同时”使用的设备（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。 

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212129180.png" alt="image-20230721212916135" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212129669.png" alt=".*?" style="zoom:67%;" />


 当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：


+ 在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；
+ 为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。


虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。 SPOOLing 技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。

<img src="https://cdn.jsdelivr.net/gh/ZeirSor/picgo_img@main/202307212129993.png" alt="image-20230721212958937" style="zoom:67%;" />


### 2.7. 补充

+ 什么是设备的独立性？引入设备的独立性有什么好处？ **设备独立性**是指用户在编程序时使用的设备与实际设备无关。一个程序应独立于分配给它的某类设备的具体设备，即在用户程序中只指明I/O使用的设备类型即可。 设备独立性有以下优点： ①方便用户编程。 ②使程序运行不受具体机器环境的限制。 ③便于程序移植。
+ 磁盘属于共享设备。**共享设备**是指在一个时间间隔内可被多个进程同时访问的设备。 打印机和磁带机都不属于。打印机在一个时间间隔内被多个进程访问时打印出来的文档就会乱；磁带机旋转到所需的读写位置需要较长时间，若一个时间间隔内被多个进程访问，磁带机就只能一直旋转，没时间读写。
+ 程序员利用系统调用打开I/O设备时，通常使用的设备标识是逻辑设备名。用户程序对I/O设备的请求采用逻辑设备名，而程序实际执行时使用物理设备名，它们之间的转换是由设备无关软件层完成的。
+ 可以改善磁盘I/O性能的是重排I/O请求次序、预读和滞后写、优化文件物理块的分布。重排I/O请求次序是进行I/O调度，使进程之间公平地共享磁盘访问，减少I/O完成所需要的平均等待时间；缓冲区结合预读和滞后写技术对于具有重复性及阵发性的I/O进程改善磁盘I/O性能很有帮助；优化文件物理块的分布可以减少寻找时间与延迟时间，从而提高磁盘性能。
+ 为了使并发进程能有效地进行输入和输出，最好采用缓冲池结构的缓存技术。缓冲池是系统的共用资源，可供多个进程共享。
+ 输入井和输出井是在磁盘上开辟的存储空间，而输入/输出缓冲区则是在内存中开辟的。所以缓冲技术的缓冲区是在内存中的。
+ 若I/O所花费的时间比CPU的处理时间短得多，则缓冲区几乎无效。因为缓冲区主要解决输入/输出速度比CPU处理的速度满而造成数据积压的矛盾。
+ 缓冲区管理要重要考虑的问题是实现进程访问缓冲区的同步。在缓冲机制中，无论是单缓冲、多缓冲还是缓冲池，由于缓冲区是一种临界资源，所以在使用缓冲区时都有一个申请和释放（及互斥）的问题需要考虑。
+ 提高单机资源利用率的关键技术是多道程序设计技术。在单机系统中，最关键的资源是处理机资源，最大化地提高处理机利用率，技术最大化地提高系统效率。多道程序设计技术是提高处理机利用率的关键技术。
+ SPOOLing技术可将独占设备改造为共享设备，其主要目的是提高系统资源/独占设备的利用率。
+ SPOOLing技术需要使用磁盘空间（输入井和输出井）和内存空间（输入/输出缓冲区），并不需要外围计算机的支持。
+ 在SPOOLing系统中，用户进程实际分配到的是外存区，即虚拟设备。
+ SPOOLing技术是操作系统中采用的以空间换取时间的技术。
+ 在SPOOLing系统中，设备与输入井/输出井之间数据的传送是由系统实现的。
